# One away edits can be grouped into 3 categories: add a character, remove a character and 
# replace a character. Write a method that checks if a string is one or zero edits 
# away from another

# First Solution: Go through the first string and check if the second string has all the
# characters as the first except 1 as with one awaya there should be an exact match on
# all other elements
# Runtime Complexity O(N + K + H) || Algorithm first goes over the initial set(N), then the
# second set(K) and finally the thrid set generated by unique characters
# Size Complexity: O(N + K) || In the worst case, generates a dictionary of size equal to the number
# of elements in the first set (N) and the second set (K)
def is_one_away(string_1, string_2):
    unique_items = {}
    
    # Get the all the characters in the set and count their occurences
    for char in string_1:
        if unique_items.get(char) == None:
            unique_items[char] = 1
        else:
            unique_items[char] += 1
    
    # Remove all the instances of characters in the second string from the dictionary
    for char in string_2:
        if unique_items.get(char) == None:
            unique_items[char] = -1
        else:
            unique_items[char] -= 1
    
    # Finds how many "off" the second string is from the first
    issue_counter = 0
    for key in unique_items:
        if unique_items[key] < 0:
            issue_counter += -unique_items[key] 
        elif unique_items[key] > 1:
            issue_counter += unique_items[key]

    if issue_counter > 1:
        return False

    return True

if __name__ == "__main__":
    print(is_one_away("Hello", "Hello"))
    print(is_one_away("Hello", "Hello1"))
    print(is_one_away("Hello", "Hello11"))
    print(is_one_away("Hello", "He4llo"))
    print(is_one_away("Hello", "Hllo"))
    print(is_one_away("There once was a man who wore a hat.",
        "There once was a man who adored a mat"))